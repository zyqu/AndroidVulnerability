// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.geocities.com/kpdus/jad.html
// Decompiler options: packimports(3) 

package org.apache.cordova;

import android.content.ContentResolver;
import android.database.Cursor;
import android.net.Uri;
import android.os.Environment;
import android.webkit.MimeTypeMap;
import java.io.*;
import java.net.*;
import java.nio.channels.FileChannel;
import org.apache.commons.codec.binary.Base64;
import org.apache.cordova.api.CordovaInterface;
import org.apache.cordova.api.Plugin;
import org.apache.cordova.api.PluginResult;
import org.apache.cordova.file.EncodingException;
import org.apache.cordova.file.FileExistsException;
import org.apache.cordova.file.InvalidModificationException;
import org.apache.cordova.file.NoModificationAllowedException;
import org.apache.cordova.file.TypeMismatchException;
import org.json.*;

// Referenced classes of package org.apache.cordova:
//            DirectoryManager

public class FileUtils extends Plugin
{

    public FileUtils()
    {
    }

    private boolean atRootDirectory(String s)
    {
        String s1 = stripFileProtocol(s);
        boolean flag;
        if(s1.equals((new StringBuilder()).append(Environment.getExternalStorageDirectory().getAbsolutePath()).append("/Android/data/").append(ctx.getPackageName()).append("/cache").toString()) || s1.equals(Environment.getExternalStorageDirectory().getAbsolutePath()) || s1.equals((new StringBuilder()).append("/data/data/").append(ctx.getPackageName()).toString()))
            flag = true;
        else
            flag = false;
        return flag;
    }

    private JSONObject copyDirectory(File file, File file1)
        throws JSONException, IOException, NoModificationAllowedException, InvalidModificationException
    {
        if(file1.exists() && file1.isFile())
            throw new InvalidModificationException("Can't rename a file to a directory");
        if(isCopyOnItself(file.getAbsolutePath(), file1.getAbsolutePath()))
            throw new InvalidModificationException("Can't copy itself into itself");
        if(!file1.exists() && !file1.mkdir())
            throw new NoModificationAllowedException("Couldn't create the destination direcotry");
        File afile[] = file.listFiles();
        int i = afile.length;
        int j = 0;
        while(j < i) 
        {
            File file2 = afile[j];
            if(file2.isDirectory())
                copyDirectory(file2, file1);
            else
                copyFile(file2, new File((new StringBuilder()).append(file1.getAbsoluteFile()).append(File.separator).append(file2.getName()).toString()));
            j++;
        }
        return getEntry(file1);
    }

    private JSONObject copyFile(File file, File file1)
        throws IOException, InvalidModificationException, JSONException
    {
        if(file1.exists() && file1.isDirectory())
        {
            throw new InvalidModificationException("Can't rename a file to a directory");
        } else
        {
            FileChannel filechannel = (new FileInputStream(file)).getChannel();
            FileChannel filechannel1 = (new FileOutputStream(file1)).getChannel();
            filechannel.transferTo(0L, filechannel.size(), filechannel1);
            filechannel.close();
            filechannel1.close();
            return getEntry(file1);
        }
    }

    private File createDestination(String s, File file, File file1)
    {
        if("null".equals(s) || "".equals(s))
            s = null;
        File file2;
        if(s != null)
            file2 = new File((new StringBuilder()).append(file1.getAbsolutePath()).append(File.separator).append(s).toString());
        else
            file2 = new File((new StringBuilder()).append(file1.getAbsolutePath()).append(File.separator).append(file.getName()).toString());
        return file2;
    }

    private File createFileObject(String s)
    {
        return new File(stripFileProtocol(s));
    }

    private File createFileObject(String s, String s1)
    {
        File file;
        if(s1.startsWith("/"))
        {
            file = new File(s1);
        } else
        {
            String s2 = stripFileProtocol(s);
            file = new File((new StringBuilder()).append(s2).append(File.separator).append(s1).toString());
        }
        return file;
    }

    private JSONObject getEntry(String s)
        throws JSONException
    {
        return getEntry(new File(s));
    }

    private JSONObject getFile(String s, String s1, JSONObject jsonobject, boolean flag)
        throws FileExistsException, IOException, TypeMismatchException, EncodingException, JSONException
    {
        boolean flag1 = false;
        boolean flag2 = false;
        if(jsonobject != null)
        {
            flag1 = jsonobject.optBoolean("create");
            if(flag1)
                flag2 = jsonobject.optBoolean("exclusive");
        }
        if(s1.contains(":"))
            throw new EncodingException("This file has a : in it's name");
        File file = createFileObject(s, s1);
        if(flag1)
        {
            if(flag2 && file.exists())
                throw new FileExistsException("create/exclusive fails");
            if(flag)
                file.mkdir();
            else
                file.createNewFile();
            if(!file.exists())
                throw new FileExistsException("create fails");
        } else
        {
            if(!file.exists())
                throw new FileNotFoundException("path does not exist");
            if(flag)
            {
                if(file.isFile())
                    throw new TypeMismatchException("path doesn't exist or is file");
            } else
            if(file.isDirectory())
                throw new TypeMismatchException("path doesn't exist or is directory");
        }
        return getEntry(file);
    }

    private JSONObject getFileMetadata(String s)
        throws FileNotFoundException, JSONException
    {
        File file = createFileObject(s);
        if(!file.exists())
        {
            throw new FileNotFoundException((new StringBuilder()).append("File: ").append(s).append(" does not exist.").toString());
        } else
        {
            JSONObject jsonobject = new JSONObject();
            jsonobject.put("size", file.length());
            jsonobject.put("type", getMimeType(s));
            jsonobject.put("name", file.getName());
            jsonobject.put("fullPath", file.getAbsolutePath());
            jsonobject.put("lastModifiedDate", file.lastModified());
            return jsonobject;
        }
    }

    private JSONObject getMetadata(String s)
        throws FileNotFoundException, JSONException
    {
        File file = createFileObject(s);
        if(!file.exists())
        {
            throw new FileNotFoundException("Failed to find file in getMetadata");
        } else
        {
            JSONObject jsonobject = new JSONObject();
            jsonobject.put("modificationTime", file.lastModified());
            return jsonobject;
        }
    }

    public static String getMimeType(String s)
    {
        return MimeTypeMap.getSingleton().getMimeTypeFromExtension(MimeTypeMap.getFileExtensionFromUrl(s));
    }

    private JSONObject getParent(String s)
        throws JSONException
    {
        String s1 = stripFileProtocol(s);
        JSONObject jsonobject;
        if(atRootDirectory(s1))
            jsonobject = getEntry(s1);
        else
            jsonobject = getEntry((new File(s1)).getParent());
        return jsonobject;
    }

    private InputStream getPathFromUri(String s)
        throws FileNotFoundException
    {
        Object obj;
        if(s.startsWith("content"))
        {
            Uri uri = Uri.parse(s);
            obj = ctx.getContentResolver().openInputStream(uri);
        } else
        {
            obj = new FileInputStream(stripFileProtocol(s));
        }
        return ((InputStream) (obj));
    }

    protected static String getRealPathFromURI(Uri uri, CordovaInterface cordovainterface)
    {
        Cursor cursor = cordovainterface.managedQuery(uri, new String[] {
            "_data"
        }, null, null, null);
        int i = cursor.getColumnIndexOrThrow("_data");
        cursor.moveToFirst();
        return cursor.getString(i);
    }

    private boolean isCopyOnItself(String s, String s1)
    {
        boolean flag;
        if(s1.startsWith(s) && s1.indexOf(File.separator, s.length() - 1) != -1)
            flag = true;
        else
            flag = false;
        return flag;
    }

    private JSONObject moveDirectory(File file, File file1)
        throws JSONException, InvalidModificationException
    {
        if(file1.exists() && file1.isFile())
            throw new InvalidModificationException("Can't rename a file to a directory");
        if(isCopyOnItself(file.getAbsolutePath(), file1.getAbsolutePath()))
            throw new InvalidModificationException("Can't move itself into itself");
        if(file1.exists() && file1.list().length > 0)
        {
            throw new InvalidModificationException("directory is not empty");
        } else
        {
            if(file.renameTo(file1));
            return getEntry(file1);
        }
    }

    private JSONObject moveFile(File file, File file1)
        throws JSONException, InvalidModificationException
    {
        if(file1.exists() && file1.isDirectory())
        {
            throw new InvalidModificationException("Can't rename a file to a directory");
        } else
        {
            if(file.renameTo(file1));
            return getEntry(file1);
        }
    }

    private void notifyDelete(String s)
    {
        ctx.getContentResolver().delete(android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI, "_data = ?", new String[] {
            s
        });
    }

    private JSONArray readEntries(String s)
        throws FileNotFoundException, JSONException
    {
        File file = createFileObject(s);
        if(!file.exists())
            throw new FileNotFoundException();
        JSONArray jsonarray = new JSONArray();
        if(file.isDirectory())
        {
            File afile[] = file.listFiles();
            for(int i = 0; i < afile.length; i++)
                jsonarray.put(getEntry(afile[i]));

        }
        return jsonarray;
    }

    private boolean remove(String s)
        throws NoModificationAllowedException, InvalidModificationException
    {
        File file = createFileObject(s);
        if(atRootDirectory(s))
            throw new NoModificationAllowedException("You can't delete the root directory");
        if(file.isDirectory() && file.list().length > 0)
            throw new InvalidModificationException("You can't delete a directory that is not empty.");
        else
            return file.delete();
    }

    private boolean removeDirRecursively(File file)
        throws FileExistsException
    {
        if(file.isDirectory())
        {
            File afile[] = file.listFiles();
            int i = afile.length;
            for(int j = 0; j < i; j++)
                removeDirRecursively(afile[j]);

        }
        if(!file.delete())
            throw new FileExistsException((new StringBuilder()).append("could not delete: ").append(file.getName()).toString());
        else
            return true;
    }

    private boolean removeRecursively(String s)
        throws FileExistsException
    {
        File file = createFileObject(s);
        boolean flag;
        if(atRootDirectory(s))
            flag = false;
        else
            flag = removeDirRecursively(file);
        return flag;
    }

    private JSONObject requestFileSystem(int i)
        throws IOException, JSONException
    {
        JSONObject jsonobject = new JSONObject();
        if(i == TEMPORARY)
        {
            jsonobject.put("name", "temporary");
            if(Environment.getExternalStorageState().equals("mounted"))
            {
                (new File((new StringBuilder()).append(Environment.getExternalStorageDirectory().getAbsolutePath()).append("/Android/data/").append(ctx.getPackageName()).append("/cache/").toString())).mkdirs();
                jsonobject.put("root", getEntry((new StringBuilder()).append(Environment.getExternalStorageDirectory().getAbsolutePath()).append("/Android/data/").append(ctx.getPackageName()).append("/cache/").toString()));
            } else
            {
                (new File((new StringBuilder()).append("/data/data/").append(ctx.getPackageName()).append("/cache/").toString())).mkdirs();
                jsonobject.put("root", getEntry((new StringBuilder()).append("/data/data/").append(ctx.getPackageName()).append("/cache/").toString()));
            }
        } else
        if(i == PERSISTENT)
        {
            jsonobject.put("name", "persistent");
            if(Environment.getExternalStorageState().equals("mounted"))
                jsonobject.put("root", getEntry(Environment.getExternalStorageDirectory()));
            else
                jsonobject.put("root", getEntry((new StringBuilder()).append("/data/data/").append(ctx.getPackageName()).toString()));
        } else
        {
            throw new IOException("No filesystem of type requested");
        }
        return jsonobject;
    }

    private JSONObject resolveLocalFileSystemURI(String s)
        throws IOException, JSONException
    {
        String s1 = URLDecoder.decode(s, "UTF-8");
        File file;
        if(s1.startsWith("content:"))
        {
            Cursor cursor = ctx.managedQuery(Uri.parse(s1), new String[] {
                "_data"
            }, null, null, null);
            int i = cursor.getColumnIndexOrThrow("_data");
            cursor.moveToFirst();
            file = new File(cursor.getString(i));
        } else
        {
            new URL(s1);
            if(s1.startsWith("file://"))
                file = new File(s1.substring(7, s1.length()));
            else
                file = new File(s1);
        }
        if(!file.exists())
            throw new FileNotFoundException();
        if(!file.canRead())
            throw new IOException();
        else
            return getEntry(file);
    }

    private String stripFileProtocol(String s)
    {
        if(s.startsWith("file://"))
            s = s.substring(7);
        return s;
    }

    private JSONObject transferTo(String s, String s1, String s2, boolean flag)
        throws JSONException, NoModificationAllowedException, IOException, InvalidModificationException, EncodingException
    {
        String s3 = stripFileProtocol(s);
        String s4 = stripFileProtocol(s1);
        if(s2 != null && s2.contains(":"))
            throw new EncodingException("Bad file name");
        File file = new File(s3);
        if(!file.exists())
            throw new FileNotFoundException("The source does not exist");
        File file1 = new File(s4);
        if(!file1.exists())
            throw new FileNotFoundException("The source does not exist");
        File file2 = createDestination(s2, file, file1);
        if(file.getAbsolutePath().equals(file2.getAbsolutePath()))
            throw new InvalidModificationException("Can't copy a file onto itself");
        JSONObject jsonobject;
        if(file.isDirectory())
        {
            if(flag)
                jsonobject = moveDirectory(file, file2);
            else
                jsonobject = copyDirectory(file, file2);
        } else
        if(flag)
            jsonobject = moveFile(file, file2);
        else
            jsonobject = copyFile(file, file2);
        return jsonobject;
    }

    private long truncateFile(String s, long l)
        throws FileNotFoundException, IOException
    {
        RandomAccessFile randomaccessfile = new RandomAccessFile(stripFileProtocol(s), "rw");
        long l1;
        if(randomaccessfile.length() >= l)
        {
            randomaccessfile.getChannel().truncate(l);
            l1 = l;
        } else
        {
            l1 = randomaccessfile.length();
        }
        return l1;
    }

    public PluginResult execute(String s, JSONArray jsonarray, String s1)
    {
        org.apache.cordova.api.PluginResult.Status status = org.apache.cordova.api.PluginResult.Status.OK;
        PluginResult pluginresult;
        FileNotFoundException filenotfoundexception;
        if(s.equals("testSaveLocationExists"))
        {
            boolean flag2 = DirectoryManager.testSaveLocationExists();
            pluginresult = new PluginResult(status, flag2);
            break MISSING_BLOCK_LABEL_1093;
        }
        if(s.equals("getFreeDiskSpace"))
        {
            long l3 = DirectoryManager.getFreeDiskSpace(false);
            float f2 = l3;
            pluginresult = new PluginResult(status, f2);
            break MISSING_BLOCK_LABEL_1093;
        }
        FileExistsException fileexistsexception;
        if(s.equals("testFileExists"))
        {
            boolean flag1 = DirectoryManager.testFileExists(jsonarray.getString(0));
            pluginresult = new PluginResult(status, flag1);
            break MISSING_BLOCK_LABEL_1093;
        }
        NoModificationAllowedException nomodificationallowedexception;
        if(s.equals("testDirectoryExists"))
        {
            boolean flag = DirectoryManager.testFileExists(jsonarray.getString(0));
            pluginresult = new PluginResult(status, flag);
            break MISSING_BLOCK_LABEL_1093;
        }
        JSONException jsonexception;
        if(s.equals("readAsText"))
        {
            String s3 = readAsText(jsonarray.getString(0), jsonarray.getString(1));
            pluginresult = new PluginResult(status, s3);
            break MISSING_BLOCK_LABEL_1093;
        }
        InvalidModificationException invalidmodificationexception;
        if(s.equals("readAsDataURL"))
        {
            String s2 = readAsDataURL(jsonarray.getString(0));
            pluginresult = new PluginResult(status, s2);
            break MISSING_BLOCK_LABEL_1093;
        }
        MalformedURLException malformedurlexception;
        if(s.equals("write"))
        {
            long l2 = write(jsonarray.getString(0), jsonarray.getString(1), jsonarray.getInt(2));
            float f1 = l2;
            pluginresult = new PluginResult(status, f1);
            break MISSING_BLOCK_LABEL_1093;
        }
        IOException ioexception;
        if(s.equals("truncate"))
        {
            long l1 = truncateFile(jsonarray.getString(0), jsonarray.getLong(1));
            float f = l1;
            pluginresult = new PluginResult(status, f);
            break MISSING_BLOCK_LABEL_1093;
        }
        if(s.equals("requestFileSystem"))
        {
            long l = jsonarray.optLong(1);
            EncodingException encodingexception;
            if(l != 0L && l > 1024L * DirectoryManager.getFreeDiskSpace(true))
            {
                pluginresult = new PluginResult(org.apache.cordova.api.PluginResult.Status.ERROR, QUOTA_EXCEEDED_ERR);
                break MISSING_BLOCK_LABEL_1093;
            }
            try
            {
                JSONObject jsonobject8 = requestFileSystem(jsonarray.getInt(0));
                pluginresult = new PluginResult(status, jsonobject8);
            }
            // Misplaced declaration of an exception variable
            catch(FileNotFoundException filenotfoundexception)
            {
                pluginresult = new PluginResult(org.apache.cordova.api.PluginResult.Status.ERROR, NOT_FOUND_ERR);
            }
            // Misplaced declaration of an exception variable
            catch(FileExistsException fileexistsexception)
            {
                pluginresult = new PluginResult(org.apache.cordova.api.PluginResult.Status.ERROR, PATH_EXISTS_ERR);
            }
            // Misplaced declaration of an exception variable
            catch(NoModificationAllowedException nomodificationallowedexception)
            {
                pluginresult = new PluginResult(org.apache.cordova.api.PluginResult.Status.ERROR, NO_MODIFICATION_ALLOWED_ERR);
            }
            // Misplaced declaration of an exception variable
            catch(JSONException jsonexception)
            {
                pluginresult = new PluginResult(org.apache.cordova.api.PluginResult.Status.ERROR, NO_MODIFICATION_ALLOWED_ERR);
            }
            // Misplaced declaration of an exception variable
            catch(InvalidModificationException invalidmodificationexception)
            {
                pluginresult = new PluginResult(org.apache.cordova.api.PluginResult.Status.ERROR, INVALID_MODIFICATION_ERR);
            }
            // Misplaced declaration of an exception variable
            catch(MalformedURLException malformedurlexception)
            {
                pluginresult = new PluginResult(org.apache.cordova.api.PluginResult.Status.ERROR, ENCODING_ERR);
            }
            // Misplaced declaration of an exception variable
            catch(IOException ioexception)
            {
                pluginresult = new PluginResult(org.apache.cordova.api.PluginResult.Status.ERROR, INVALID_MODIFICATION_ERR);
            }
            // Misplaced declaration of an exception variable
            catch(EncodingException encodingexception)
            {
                pluginresult = new PluginResult(org.apache.cordova.api.PluginResult.Status.ERROR, ENCODING_ERR);
            }
            catch(TypeMismatchException typemismatchexception)
            {
                pluginresult = new PluginResult(org.apache.cordova.api.PluginResult.Status.ERROR, TYPE_MISMATCH_ERR);
            }
            break MISSING_BLOCK_LABEL_1093;
        }
        if(s.equals("resolveLocalFileSystemURI"))
        {
            JSONObject jsonobject7 = resolveLocalFileSystemURI(jsonarray.getString(0));
            pluginresult = new PluginResult(status, jsonobject7);
        } else
        if(s.equals("getMetadata"))
        {
            JSONObject jsonobject6 = getMetadata(jsonarray.getString(0));
            pluginresult = new PluginResult(status, jsonobject6);
        } else
        if(s.equals("getFileMetadata"))
        {
            JSONObject jsonobject5 = getFileMetadata(jsonarray.getString(0));
            pluginresult = new PluginResult(status, jsonobject5);
        } else
        if(s.equals("getParent"))
        {
            JSONObject jsonobject4 = getParent(jsonarray.getString(0));
            pluginresult = new PluginResult(status, jsonobject4);
        } else
        if(s.equals("getDirectory"))
        {
            JSONObject jsonobject3 = getFile(jsonarray.getString(0), jsonarray.getString(1), jsonarray.optJSONObject(2), true);
            pluginresult = new PluginResult(status, jsonobject3);
        } else
        if(s.equals("getFile"))
        {
            JSONObject jsonobject2 = getFile(jsonarray.getString(0), jsonarray.getString(1), jsonarray.optJSONObject(2), false);
            pluginresult = new PluginResult(status, jsonobject2);
        } else
        if(s.equals("remove"))
        {
            if(remove(jsonarray.getString(0)))
            {
                notifyDelete(jsonarray.getString(0));
                pluginresult = new PluginResult(status);
            } else
            {
                pluginresult = new PluginResult(org.apache.cordova.api.PluginResult.Status.ERROR, NO_MODIFICATION_ALLOWED_ERR);
            }
        } else
        if(s.equals("removeRecursively"))
        {
            if(removeRecursively(jsonarray.getString(0)))
                pluginresult = new PluginResult(status);
            else
                pluginresult = new PluginResult(org.apache.cordova.api.PluginResult.Status.ERROR, NO_MODIFICATION_ALLOWED_ERR);
        } else
        if(s.equals("moveTo"))
        {
            JSONObject jsonobject1 = transferTo(jsonarray.getString(0), jsonarray.getString(1), jsonarray.getString(2), true);
            pluginresult = new PluginResult(status, jsonobject1);
        } else
        if(s.equals("copyTo"))
        {
            JSONObject jsonobject = transferTo(jsonarray.getString(0), jsonarray.getString(1), jsonarray.getString(2), false);
            pluginresult = new PluginResult(status, jsonobject);
        } else
        if(s.equals("readEntries"))
        {
            JSONArray jsonarray1 = readEntries(jsonarray.getString(0));
            pluginresult = new PluginResult(status, jsonarray1);
        } else
        {
            pluginresult = new PluginResult(status, "");
        }
        return pluginresult;
    }

    public JSONObject getEntry(File file)
        throws JSONException
    {
        JSONObject jsonobject = new JSONObject();
        jsonobject.put("isFile", file.isFile());
        jsonobject.put("isDirectory", file.isDirectory());
        jsonobject.put("name", file.getName());
        jsonobject.put("fullPath", (new StringBuilder()).append("file://").append(file.getAbsolutePath()).toString());
        return jsonobject;
    }

    public boolean isSynch(String s)
    {
        boolean flag;
        if(s.equals("testSaveLocationExists"))
            flag = true;
        else
        if(s.equals("getFreeDiskSpace"))
            flag = true;
        else
        if(s.equals("testFileExists"))
            flag = true;
        else
        if(s.equals("testDirectoryExists"))
            flag = true;
        else
            flag = false;
        return flag;
    }

    public String readAsDataURL(String s)
        throws FileNotFoundException, IOException
    {
        byte abyte0[] = new byte[1000];
        BufferedInputStream bufferedinputstream = new BufferedInputStream(getPathFromUri(s), 1024);
        ByteArrayOutputStream bytearrayoutputstream = new ByteArrayOutputStream();
        do
        {
            int i = bufferedinputstream.read(abyte0, 0, 1000);
            if(i < 0)
                break;
            bytearrayoutputstream.write(abyte0, 0, i);
        } while(true);
        String s1;
        byte abyte1[];
        if(s.startsWith("content:"))
        {
            Uri uri = Uri.parse(s);
            s1 = ctx.getContentResolver().getType(uri);
        } else
        {
            s1 = getMimeType(s);
        }
        abyte1 = Base64.encodeBase64(bytearrayoutputstream.toByteArray());
        return (new StringBuilder()).append("data:").append(s1).append(";base64,").append(new String(abyte1)).toString();
    }

    public String readAsText(String s, String s1)
        throws FileNotFoundException, IOException
    {
        byte abyte0[] = new byte[1000];
        BufferedInputStream bufferedinputstream = new BufferedInputStream(getPathFromUri(s), 1024);
        ByteArrayOutputStream bytearrayoutputstream = new ByteArrayOutputStream();
        do
        {
            int i = bufferedinputstream.read(abyte0, 0, 1000);
            if(i >= 0)
                bytearrayoutputstream.write(abyte0, 0, i);
            else
                return new String(bytearrayoutputstream.toByteArray(), s1);
        } while(true);
    }

    public long write(String s, String s1, int i)
        throws FileNotFoundException, IOException
    {
        String s2 = stripFileProtocol(s);
        boolean flag = false;
        if(i > 0)
        {
            truncateFile(s2, i);
            flag = true;
        }
        byte abyte0[] = s1.getBytes();
        ByteArrayInputStream bytearrayinputstream = new ByteArrayInputStream(abyte0);
        FileOutputStream fileoutputstream = new FileOutputStream(s2, flag);
        byte abyte1[] = new byte[abyte0.length];
        bytearrayinputstream.read(abyte1, 0, abyte1.length);
        fileoutputstream.write(abyte1, 0, abyte0.length);
        fileoutputstream.flush();
        fileoutputstream.close();
        return (long)s1.length();
    }

    public static int ABORT_ERR = 0;
    public static int APPLICATION = 0;
    public static int ENCODING_ERR = 0;
    public static int INVALID_MODIFICATION_ERR = 0;
    public static int INVALID_STATE_ERR = 0;
    private static final String LOG_TAG = "FileUtils";
    public static int NOT_FOUND_ERR = 0;
    public static int NOT_READABLE_ERR = 0;
    public static int NO_MODIFICATION_ALLOWED_ERR = 0;
    public static int PATH_EXISTS_ERR = 0;
    public static int PERSISTENT = 0;
    public static int QUOTA_EXCEEDED_ERR = 0;
    public static int RESOURCE = 0;
    public static int SECURITY_ERR = 0;
    public static int SYNTAX_ERR = 0;
    public static int TEMPORARY = 0;
    public static int TYPE_MISMATCH_ERR = 0;
    private static final String _DATA = "_data";
    FileReader f_in;
    FileWriter f_out;

    static 
    {
        NOT_FOUND_ERR = 1;
        SECURITY_ERR = 2;
        ABORT_ERR = 3;
        NOT_READABLE_ERR = 4;
        ENCODING_ERR = 5;
        NO_MODIFICATION_ALLOWED_ERR = 6;
        INVALID_STATE_ERR = 7;
        SYNTAX_ERR = 8;
        INVALID_MODIFICATION_ERR = 9;
        QUOTA_EXCEEDED_ERR = 10;
        TYPE_MISMATCH_ERR = 11;
        PATH_EXISTS_ERR = 12;
        TEMPORARY = 0;
        PERSISTENT = 1;
        RESOURCE = 2;
        APPLICATION = 3;
    }
}
